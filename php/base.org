* 理念
+ 一个网站就是一个文件夹
+ 一个网页就是一个文件
* 一些概念
+ url 统一资源定位器
+ 网址：协议:域名[端口号][路径][文件名]
* 变量
+ 以 $ 开始
+ 紧接着必须是数字或字母
+ 之后的还可以是数字
+ 不能是关键字
+ 尽量见名知意
+ 推荐小驼峰

* debug 辅助函数
** echo
+ true -> 1
+ false/null/NULL 没有输出
+ null 什么都没有输出
** var_dump($x)
输出变量（必须定义）的详细信息

* 显示时间信息
#+BEGIN_SRC php
  echo date('Y-m-d H:i:s');
  echo idate('w'); // week info
#+END_SRC

* 操作变量
+ 赋值
+ 取值
+ 判断是否存在：isset($x); null 和 未定义为 false，其他为 true
+ 销毁：unset($x); 之后使用变量就是未定义，需要重新定义

* 引用
类似 C++ 的引用，可以看成是别名（数据中的内存是同一地址）
#+BEGIN_SRC perl
  $a = 1000;
  $b = &$a;
  $a = 100;
#+END_SRC

* 预定义变量
** 获取请求的参数
+ $_GET get 请求
+ $_POST post 请求
+ $_REQUEST （不分是 get 还是 post 请求）
#+BEGIN_SRC php
  <?php
  $l = $r = $result = '';
  if (isset($_REQUEST['l']) && $r = $_REQUEST['r']) {
      $l = $_REQUEST['l'];
      $r = $_REQUEST['r'];
      $result = $l + $r;
  }
  ?>
  <!--同时有 post get 数据-->
  <form action="calc2.php?name=elem&age=12" method="post">
      <div>
	  <input type="text"
		 name="l"
		 value="<?php echo $l; ?>"/>
	  +
	  <input type="text"
		 name="r"
		 value="<?php echo $l; ?>"/>
	  <input type='submit' value="计算">
	  <?php echo $result ?>
      </div>
  </form>
#+END_SRC

** $_SERVER
仅列出一些简单的，剩下需要查手册
#+BEGIN_SRC php
  echo '<p>php file: ', $_SERVER['PHP_SELF'];
  echo '<p>domain name: ', $_SERVER['SERVER_NAME'];
  echo '<p>server ip: ', $_SERVER['REMOTE_ADDR'];
  echo '<p>document root path: ', $_SERVER['DOCUMENT_ROOT'];
  echo '<p>script name: ', $_SERVER['SCRIPT_NAME'];
  echo '<p>client ip: ', $_SERVER['REMOTE_ADDR'];
#+END_SRC
* 可变变量
使用变量名找变量
#+BEGIN_SRC php
  $a = 1;
  $b = 'a';
  $c = 'b';
  //$$$c;
  //$$b;
  //$a
  echo $$$c;
#+END_SRC
* 常量
** const 
定义时只能使用字面量和简单计算的表达式
#+BEGIN_SRC php
  const AGE = 100;

  echo 'len: ', LEN * 2 - 71;
  echo '<br/>age: ', AGE * 2 - 33;
#+END_SRC
** define
定义时值可以是复杂的表达式
#+BEGIN_SRC php
  define('LEN', 100);

  echo 'len: ', LEN * 2 - 71;
  echo '<br/>age: ', AGE * 2 - 33;

  //避免冲突
  $varName = 'AGE';
  if(!defined($varName)){
      define($varName, 11);
  }
  echo '<br/>const value ', $varName, ' : ',constant($varName);
#+END_SRC
** 预定义常量
列了一些，其他查手册
#+BEGIN_SRC php
  echo '<br/>', PHP_VERSION;
  echo '<br/>', PHP_OS;
  echo '<br/>', PHP_INT_MAX;
  echo '<br/>', M_PI;
#+END_SRC
** 魔术常量
列了一些，其他查手册
#+BEGIN_SRC php
  echo '<br/>', __DIR__;
  echo '<br/>', __FILE__;
  echo '<br/>', __LINE__;
  //echo '<br/>', __FUNCTION__;
#+END_SRC
* 进制
使用内置的函数
#+BEGIN_SRC php
  //进制转换
  $a = 0x111;
  $c = 111;
  $b = 0111;
  $d = 0b111;

  echo '<br/> 0x111: ' . $a;
  echo '<br/> 111: ' . $b;
  echo '<br/> 0111: ' . $c;
  echo '<br/> 0b111: ' . $d;

  //10进制转其他
  $v = 100;
  echo '<br/>100->16: ', '0x', dechex($v);
  echo '<br/>100->8: ', '0', decoct($v);
  echo '<br/>100->2: ', '0b', decbin($v);

  echo '<br/>011: ',octdec('011');
#+END_SRC
* 浮点数
浮点数相等操作不可靠，不要随便进行比较（一般转整数比较）
#+BEGIN_SRC php
  echo '<br/>1.6: ', 1.6;
  echo '<br/>1.23e3: ', 1.23e3;
#+END_SRC
* 布尔值
+ true
+ false

* 字符串
+ 单引号不会解析
+ 双引号中会解析变量($x)
+ 双引号中变量转义后不会解析，\$x 只会生效一次，不解析的都需要转义
+ 显示指定变量
#+BEGIN_SRC php
  $s = 'hello';
  //效果相同
  echo "<br/>$s";
  echo "<br/>{$s}";
  echo "<br/>".$s;
  echo '<br/>'.$s;

  //效果相同
  echo "<br/>\$s: $s";
  echo "<br/>\$s: {$s}";
  echo '<br/>$s: '.$s;
  echo '<br/>$s: ',$s;

  //连接字符串不带空格也可以解析
  echo "{$s}sss";

  var_dump('abc' . '-' . true . null . '-' . false . 'ok'); //abc-ok
  $a = 'abc';
  $a .= '123';
  var_dump($a); //abc123
#+END_SRC
+ nowdoc/heredoc
#+BEGIN_SRC php
  //heredoc 类似 单引号
  $s = 'abc';
  $s1 = <<< 'aa'
  hello s1 = ${s}bb
  aa;
  var_dump($s1); //hello s1 = ${s}bb

  //nowdoc 字符串
  $s2 = <<< "bb"
  hi s2 = ${s1}
  bb;

  var_dump($s2); //'hi s2 = hello s1 = ${s}bb

  //标识符结束所在行只能写标识符紧跟着分号，不能出现空白字符
  if ("b" > 'a') {
      $s1 = <<< 'iii'
  这个只能这样子写
  iii;
  }
#+END_SRC

* 数组
数组采用的是值传递（不论是函数调用，还是赋值）
** 基本使用
#+BEGIN_SRC php
  //等价，方括号新版本支持，$_GET, $_POST 就是数组
  //key 0..
  // 添加元素
  $arr[] = 1;
  $arr[] = 2;
  $arr[] = 3;
  $p1 = array('alex', 18, 'sex');
  $p2 = ['alex', 18, 'sex'];
  //key name age gender
  $p3 = array('name' => 'xiaoli', 'age' => 10, 'gender' => 'male');
  $p4 = ['name' => 'xiaoli', 'age' => 10, 'gender' => 'male'];

  //定义并初始化数组
  $other['name'] = 'student';

  //使用属性，下标和名称
  echo "<br/>\$p1[0]: $p1[0]";
  echo "<br/>\$p3[name]: $p3[name]";
  echo "<br/>";
  echo "<pre>";//为了清晰显示原始结构
  print_r($p1, null);
  echo "</pre>";
#+END_SRC
** 分类
*** 种类划分
+ 索引数组：索引是从0开始的整数
+ 关联数组：索引都是有意义的字符串（大致这么个意思）
*** 维数划分
+ 一维数组
+ 多维数组（二位数组、三维数组...）
+ 异型数组（不整齐数组）
#+BEGIN_SRC php
  $arr = [
      [1, 2,'ab'],
      [1]
  ];
#+END_SRC
** 索引
+ 有索引使用索引
+ 没有索引的下标从0开始的整数 0 1 2 3
+ 有索引且为整数，之后没有索引的下标接着逐个增加
+ 索引会修改下标的启示值，会造成覆盖现象
#+BEGIN_SRC php
  $arr = [
      'name' => 'elex',
      18,
      "10" => '50kg',
      110,
      'gender' => 'male',
      180,
      11 => 'reset'
  ];
  //array (size=6)
  //  'name' => string 'elex' (length=4)
  //  0 => int 18
  //  10 => string '50kg' (length=4)
  //  11 => string 'reset' (length=5)
  //  'gender' => string 'male' (length=4)
  //  12 => int 180
  var_dump($arr);
#+END_SRC
** Fibonacci 数列
#+BEGIN_SRC php
  //Fibonacci 0 1 1 2 3 5 7
  function Fibonacci($n)
  {
      $beg = 0;
      $end = 1;
      for ($i = 0; $i < $n; ++$i) {
	  $tmp = $end;
	  $end = $beg + $end;
	  $beg = $tmp;
      }
      return $beg;
  }

  for ($i = 0; $i < 10; ++$i) {
      var_dump(Fibonacci($i));
  }
#+END_SRC
** 遍历
*** foreach
#+BEGIN_SRC php
  $arr = [['age' => 1, 2, 3], ['height' => 6]];
  $count = 0;
  $sum = 0;
  foreach ($arr as $a) {
      foreach ($a as $key => $val) {
	  var_dump($key);
	  ++$count;
	  $sum += $val;
      }
  }
  var_dump('srm: ' . $sum);
  var_dump('avg: ' . ($sum / $count));
#+END_SRC
*** 数组指针
#+BEGIN_SRC php
  //操作数组指针函数
  $arr = [[1, 3, 3], [2, 1]];
  reset($arr);
  $sum = $count = 0;
  for ($key = key($arr); isset($key); next($arr), $key = key($arr)) {
      for ($a = current($arr), $k = key($a); isset($k); next($a), $k = key($a)) {
	  ++$count;
	  $sum += current($a);
      }
  }
  var_dump("sum: ${sum}, count: ${count}, avg: " . ($sum / $count));

#+END_SRC
* 空类型
null/NULl 不区分大小写
#+BEGIN_SRC php
  echo false . 'abc'; // abc
  echo null . 'abc'; // abc
  $a = null;
  var_dump(isset($a)); // false
#+END_SRC

* 获取、设置、设置类型
#+BEGIN_SRC php
  echo gettype('123'); // string
  $a = 123;
  settype($a, 'string'); 
  echo gettype($a); // string

  //判断是否为某类型                // 
  var_dump(is_numeric(123)); // true
  var_dump(is_numeric('123')); // true
  var_dump(is_array([])); // true
  var_dump(is_int(10)); // true
#+END_SRC

* 判断是否为空
#+BEGIN_SRC php
  $a = null;
  //只能判断变量，undefined/null -> false, else true
  var_dump(isset($a));
  //基本类型是空和未定义都返回 true
  unset($a);
  var_dump(empty(null)); //true
  var_dump(empty($a)); //true
  var_dump(empty([])); //true
  var_dump(empty('')); //true
#+END_SRC

* 自动、强制类型转换
#+BEGIN_SRC php
  //自动类型转换
  //@是禁止警告的意思
  //基本类型相加都会转数字
  @var_dump('11' + '7abc'); // 18
  @var_dump('11' + 'abc'); // 11
  var_dump('11' + false); // 11
  var_dump('11' + true); // 12
  var_dump('11' + null); // 11
  var_dump(10.9 % 3.3); //1 (直接向下取整)
  $a = 'abc';
  @$a += 'abc';
  var_dump($a); //0

  //强制转换
  var_dump((int)'111'); //int 111
  var_dump((int)'abc'); //int 0
#+END_SRC

* 比较运算符
全等类似 javascript，要求类型和值都相同
#+BEGIN_SRC php
  var_dump(1 === '1'); // false
  var_dump(1 == '1'); // true
  var_dump(0 == '0'); // true
  var_dump(1 === true); // false
  var_dump(false == null); // true
  var_dump('aa' > 'b'); //false
#+END_SRC
* 逻辑运算符
&& || !，可以利用短路计算
* 位运算
& | ~ ^: 按位与、或、非、异或
#+BEGIN_SRC php
  //0000 0110 & 0000 1001 -> 0000 0000
  var_dump(6 & 9); // 0
  //<< >>：按位左移、右移
  //val */ 2 的 n 次方
  //0000 0010 << 4 -> 0010 0000
  var_dump(2 << 4); //32
#+END_SRC

* 错误抑制符
#+BEGIN_SRC php
  //用法，作用：去掉了警告
  @var_dump('1' + 'abc'); 
#+END_SRC
一些错误提示不应该给用户看见（系统账号改密码之类的错误）

* 运算符优先级
+ 括号有限，赋值最底
+ ! > 算数 > 比较 > 逻辑

* 字符串拼接
#+BEGIN_SRC php
  var_dump('abc' . '-' . true . null . '-' . false . 'ok'); //abc-ok
  $a = 'abc';
  $a .= '123';
  var_dump($a); //abc123
#+END_SRC

* 自增/自减
从左到右一段一段计算
#+BEGIN_SRC php
  $a = 10;
  //11 + 11 + 13 + 14 + 14 + 16 从左到右计算
  $b = ++$a + $a++ + ++$a + ++$a + $a++ + ++$a;
  echo "\$a=$a, \$b=$b"; //$a=16, $b=69

  $a = 10;
  //10-9 + 8-8 + 8-7 + 7-6 + 6-5 + 4-4 + 4-3  从左到右计算
  //10 + 8 + 8 + 7 + 6 + 4 + 4(26 + 7 + 14)
  $b = $a-- + --$a + $a-- + $a-- + $a-- + --$a + $a--;
  echo "\$a=$a, \$b=$b"; //$a=3, $b=47
#+END_SRC
* 流程结构
类似 C 中的 if-else do-while for switch while
#+BEGIN_SRC php
  //中断,可以中断几层
  //continue n 继续循环哪一层
  $n = 1;
  while(++$n < 1000){
      while(++$n < 500){
	  while (++$n < 50){
	      break 3;
	  }
      }
  }
  var_dump($n); //4
#+END_SRC
* 函数
** 简单例子
#+BEGIN_SRC php
  function add($a, $b)
  {
      return $a + $b;
  }

  var_dump(add(1, 5)); // 6
#+END_SRC
** 按值传递
#+BEGIN_SRC php
  function swap($a, $b)
  {
      $a ^= $b;
      $b = $b ^ $a;
      $a = $b ^ $a;
  }

  $oa = $na = 10;
  $ob = $nb = 20;
  swap($na, $nb);
  var_dump("$oa--$na"); //10--10
  var_dump("$ob--$nb"); //20--20
#+END_SRC
** 按引用传递
#+BEGIN_SRC php
  function swap(&$a, &$b)
  {
      $a ^= $b;
      $b = $b ^ $a;
      $a = $b ^ $a;
  }

  $oa = $na = 10;
  $ob = $nb = 20;
  swap($na, $nb);
  var_dump("$oa--$na"); //10--20
  var_dump("$ob--$nb"); //20--10
#+END_SRC
** 递归
使用了匿名函数、闭包、默认参数
#+BEGIN_SRC php
  $factorial = function ($n) {
      $fn = function ($n, $product = 1) use (&$fn) {
	  return $n <= 1 ? $product : $fn($n - 1, $n * $product);
      };
      return $fn($n);
  };

  var_dump($factorial(3) === 6); // true
  var_dump($factorial(5) === 120); // true
#+END_SRC
** 可变参数
#+BEGIN_SRC php
  function sum()
  {
      $len = func_num_args(); // args len
      $args = func_get_args(); // args arr
  //    $count = count($args); //count arr len
  //    var_dump($args);
  //    var_dump($len);
  //    var_dump($count); // arr len
      for($sum = $i = 0; $i < $len; ++$i){
	  $sum += $args[$i];
      }
      return $sum;
  }

  var_dump(sum(1, 2, 3)); // 6
#+END_SRC
** 函数简单应用
#+BEGIN_SRC php
  function add($a, $b) {
      return $a + $b;
  }
  function mul($a, $b) {
      return $a * $b;
  }
  $_POST['method'] = 'add';
  $_POST['lhs'] = '15';
  $_POST['rhs'] = '20';
  $method = $_POST['method'] ? $_POST['method'] : null;
  if (function_exists($method)) {
      $lhs = $_POST['lhs'] ? $_POST['lhs'] : '';
      $rhs = $_POST['rhs'] ? $_POST['rhs'] : '';
      var_dump($method($lhs, $rhs));
  }
#+END_SRC
** 作用域
+ 函数内外变量不能直接互相访问
+ static 变量只会初始化一次（相当于仅定义一次）
#+BEGIN_SRC php
  function fn(){
      static $c = 5;
      return ++$c;
  }
  var_dump(fn()); // 6
  var_dump(fn()); // 7
  var_dump(fn()); // 8
#+END_SRC
+ 访问作用域外的变量
#+BEGIN_SRC php
  $a = $b = 0;
  $b = 0;
  (function ($n) {
  //    方式 1，要写在函数顶部（重新声明后值会变）
  //    global 只能在函数中使用
      global $a;
      $a = +$n;

      global $a;
      $a += $n;
  //    方式 2, 使用特殊变量 GLOBALS
      $GLOBALS['b'] += $n;
  })(100);
  var_dump($a . '--' . $b); // 200--100
#+END_SRC
* 导入文件
** 使用方式和特点
#+BEGIN_SRC php
  //相当于拷贝了三次文件的代码放到这
  //重复定义函数报错，但是代码会继续执行
  //include 和 require 类似，后者出错就停止往下执行 
  include './3scope.php';
  include './3scope.php';
  include './3scope.php';

  //相当于拷贝了一次
  //include_once 和 require_once 类似，后者出错就停止往下执行
  include_once './3scope.php';
  include_once './3scope.php';
  include_once './3scope.php';
#+END_SRC
** 文件不带路径查找规则
1. php.ini 中 include_path 指定的路径找
2. 当前目录找
3. 导入文件所在目录找
** 路径相关函数
#+BEGIN_SRC php
  //当前文件的绝对地址
  var_dump(__DIR__);
  //当前访问页面的绝对路径
  var_dump(getcwd());
#+END_SRC

* 错误
** 一些系统表示错误的常量
例如：E_NOTICE、E_PARSE、E_WARNING、E_ERROR，都是整数值
** 用户错误
例如：E_USER_ERROR等和上面的类似（中间多了 user）
** 触发用户错误
#+BEGIN_SRC php
  trigger_error('触发的错误', E_USER_ERROR);
#+END_SRC
** 系统级错误配置
在 PHP 配置文件 php.ini 中修改
#+BEGIN_SRC conf
  # 显示所有错误
  error_reporting = E_ALL
  # 只显示指定错误
  error_reporting = E_NOTICE | E_PARSE
  # 开启或关闭错误显示
  display_error On | Off
  # 日志文件
  errors_log = filename
  # 开启或关闭日志
  log_errors = On | Off
#+END_SRC
** 文件级别的错误设置
#+BEGIN_SRC php
  //错误信息
  //1 on 2 off
  ini_set('display_errors', 1);
  ini_set('error_reporting', E_NOTICE | E_PARSE);

  //日志
  //1 on 2 off
  ini_set('log_errors', 1);
  ini_set('error_log', './error.log');
#+END_SRC
** 自定义错误
致命错误是系统处理，用户无权接管
#+BEGIN_SRC php
  set_error_handler('my_error');
  function my_error($code, $msg, $file,$line){
      echo "<div>
  <p>错误码：$code</p>
  <p>错误信息：$msg</p>
  <p>触发文件：$file</p>
  <p>所在行：$line</p>
  </div>";
      var_dump($code.$msg.$file.$line);
  }

  echo $a;
#+END_SRC
* 一些手册中的函数
** date
#+BEGIN_SRC php
  //时间戳
  var_dump(time());
  var_dump(microtime(true));
#+END_SRC
** string
#+BEGIN_SRC php
  var_dump(bin2hex('11')); //11 -> 4949->3131
  var_dump(strlen(chop('  1  ')));//3
  var_dump(chr(97)); //a
  var_dump(explode('.', 'www.baidu.com', 2));//[...]
  var_dump(implode('-', [1, 2])); //1-2
  var_dump(lcfirst("ABC"));//aBC
  var_dump(trim('abba','a')); //bb
  var_dump(ucfirst('abc')); //Abc
#+END_SRC
* 字符串操作的例子
#+BEGIN_SRC php
  function fn_gif()
  {
      var_dump('fn_gif');
  }

  function fn_png()
  {
      var_dump('fn_png');
  }

  function fn_jpg()
  {
      var_dump('fn_jpg');
  }

  $files = ['abc.gif', 'ax.x.jpg', 'file.JPG'];
  $len = count($files);
  for ($i = 0; $i < $len; ++$i) {
      $name = 'fn_' . strtolower(
	      substr(
		  strrchr($files[$i], '.'),
		  1
	      )
	  );
      if (function_exists($name)) {
	  $name();
      }
  }
#+END_SRC

* 简单算法
** 交换两个变量
#+BEGIN_SRC php
  function swap(&$a, &$b)
  {
      if ($a != $b) {
	  $a ^= $b;
	  $b ^= $a;
	  $a ^= $b;
      }
  }
#+END_SRC

** 排序
*** 冒泡排序
#+BEGIN_SRC php
  $arr = [4, 5, 6, 1];
  $len = count($arr);
  for ($i = 0, $stat = true; $i < $len && $stat; ++$i) {
      for ($j = 1, $stat = false; $j < $len - $i; ++$j) {
	  if ($arr[$j] < $arr[$j - 1]) {
	      $stat = true;
	      swap($arr[$j], $arr[$j - 1]);
	  }
      }
  }
  var_dump(implode($arr, ', '));
#+END_SRC
*** 选择排序
#+BEGIN_SRC php
  $arr = [4, 2, 10, 11, 16, 1, 10, -6, 10, 1];
  $len = count($arr);
  for ($i = 0; $i < $len; ++$i) {
      for ($index = 0, $j = 1; $j < $len - $i; ++$j) {
	  if ($arr[$j] > $arr[$index]) {
	      $index = $j;
	  }
      }
      swap($arr[$index], $arr[$j - 1]);
  }
  var_dump(implode($arr, ', '));
#+END_SRC
** 二分查找（折半查找）
#+BEGIN_SRC php
  $arr = [-10, -6, -1, 1, 2, 3, 4, 5, 6, 10, 11, 16, 100];
  function binary_search($arr, $value)
  {
      $search = function ($beg, $end) use (&$arr, &$value, &$search) {
	  if ($beg > $end) {
	      return false;
	  }
	  $mid = floor(($beg + $end) / 2);
	  $val = $arr[$mid];
	  if ($val === $value) {
	      return true;
	  }
	  if ($val > $value) {
	      $end = $mid - 1;
	  } else {
	      $beg = $mid + 1;
	  }
	  return $search($beg, $end);
      };
      return $search(0, count($arr) - 1);
  }

  if (binary_search($arr, 25)) {
      var_dump('find done');
  } else {
      var_dump('not find');
  }
#+END_SRC
