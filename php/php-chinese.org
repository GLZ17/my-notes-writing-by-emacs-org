* 调试小技巧
** 查看配置
   #+BEGIN_SRC php
     phpinfo();
   #+END_SRC
** 源码输出数组
   #+BEGIN_SRC php
     $fn = function (...$rest) {
	 return $rest;
     };
     //变量是内存地址
     //变量值才有类型
     echo '<pre>' . print_r($fn(1, 2), true) . '</pre>';
   #+END_SRC
** 其他的输出方式
   #+BEGIN_SRC php
     echo 'hello', 'world', '!';
     print 'hello';
     print 'world';
     print '!';
     var_dump('hello');
     var_dump('world');
     var_dump('!');
     //die、exit都可以退出程序
     die('die statement');
     exit('exit program');
   #+END_SRC
** 控制台中换行
   #+BEGIN_SRC php
     echo 'hello'.PHP_EOL;
     echo 'hello'.PHP_EOL;
   #+END_SRC
* db
** cmd
   #+BEGIN_SRC shell
     mysql -h localhost -u root -p
   #+END_SRC
** connect
   #+BEGIN_SRC php
     $joinDsn = function ($arr, $glue_k_v = '=', $glue_item = ';') {
	 $a = [];
	 foreach ($arr as $k => $v) {
	     array_push($a, $k . $glue_k_v . $v);
	 }
	 return join($glue_item, $a);
     };

     $conf = [
	 'db' => [
	     'host' => '127.0.0.1',
	     'dbname' => 'db1',
	     'port' => '3306',
	     'charset' => 'utf8'
	 ],
	 'type' => 'mysql',
	 'username' => 'root',
	 'password' => '',
     ];
     $pdo = new PDO(
	 $conf['type'] . ':' . $joinDsn($conf['db']),
	 $conf['username'],
	 $conf['password']
     );
   #+END_SRC
** operator
   #+BEGIN_SRC php
     $stmt = $pdo->query('show tables');
     print_r($stmt);
     $res = $stmt->fetchAll();
     print_r($res);

     $stmt = $pdo->prepare('insert into t (name) values (:name)');
     $res = $stmt->execute(array(':name'=>'我勒个去'));
     print_r($res);
     $res = $pdo
	 ->query('select * from t')
	 ->fetchAll(PDO::PARAM_STR);
     print_r($res);
   #+END_SRC
* 常量
  常量的定义是全局的
  #+BEGIN_SRC php
    namespace a;
    define('TEST_STRING', 'hello world');

    namespace b;
    echo TEST_STRING;
  #+END_SRC
* 魔术常量
  还有很多，查手册
  #+BEGIN_SRC php
    //魔术常量
    $fn = function (){
      echo __FUNCTION__.__DIR__.__METHOD__;
    };

    $fn();
  #+END_SRC
* 字符串
  - 拼接
    #+BEGIN_SRC php
      $s = 1 . 2;
      $s = $s . 'hi';
    #+END_SRC
  - 求长度（还有很多函数，查手册）
    #+BEGIN_SRC php
      $len = strlen($s);
    #+END_SRC
* 逻辑运算符
  - and、&&都为true为true（与）
  - or、||有一个true为true（或）
  - xor有且只有一个true为true（异或）
  - !非true为true（非）
* 组合比较符
  也叫太空船操作符
  #+BEGIN_SRC php
    $a = 10;
    $b = 20;
    $c = 10;
    //-101
    echo ($a <=> $b) . ($a <=> $c) . ($b <=> $a);
  #+END_SRC
* 数组
  - 下标
    #+BEGIN_SRC php
      $a = ['a', 2 => 'b', 'age' => 20, 'c'];
      print_r($a);
    #+END_SRC
  - 长度
    #+BEGIN_SRC php
      echo count(array(1, 2, 3));
    #+END_SRC
  - 遍历
    #+BEGIN_SRC php
      $arr = ['a', 2 => 'b', 'age' => 20, 'c'];
      foreach ($arr as $k => $v){
	  echo '$['.$k.']='.$v.';';
      }
    #+END_SRC
* function
** scope
*** global
    - global
    #+BEGIN_SRC php
      $a = 10;

      function fn1()
      {
	  global $a;
	  return $a ** 2 + 1;
      }
    #+END_SRC
    - $GLOBALS
      #+BEGIN_SRC php
	$GLOBALS['b'] = 2;
	function fn2()
	{
	    $b = $GLOBALS['b'];
	    return $b ** 3;
	}
	// 调用
	$GLOBALS['fn2'](1, 2);
	fn2(1,2);
      #+END_SRC
*** local
    函数参数，函数中变量    
    #+BEGIN_SRC php
      $fn = function ($a) {
	  $b = 10;
	  return $a + $b;
      };
    #+END_SRC
*** static
    #+BEGIN_SRC php
      $fn = function () {
	  static $ss = 0;
	  return ++$ss;
      };
    #+END_SRC
** rest parameter
     #+BEGIN_SRC php
       //php 7
       function fn(...$rest)
       {
	   return $rest;
       }
       var_dump(fn(1, 2, 3));
     #+END_SRC
** 匿名函数和闭包
   PHP不区分这两者
   #+BEGIN_SRC php

     //闭包
     function fn2()
     {
	 $num = 10;
     //    使用函数外的变量$num
     //    仅匿名函数可以这样使用
	 return function () use ($num) {
	     return ++$num;
	 };
     }
     fn2()();
   #+END_SRC
* namespace
  - 默认全局成员
  - 一个文件一般使用一个
  - 使用命名空间，第一个命名空间必须放在有效代码第一行
  #+BEGIN_SRC php
    namespace n1;
    function add($a, $b)
    {
	return $a + $b;
    }

    namespace n2;
    function add($a, $b)
    {
	return 2 * ($a + $b);
    }


    namespace n3;
    print_r(\n1\add(1, 2));
    echo '<br/>';
    print_r(\n2\add(1, 2));
  #+END_SRC
* global member
  - function
  - const
  - class
  - interface
* class
** access  
   - public 都可以访问
   - protected 定义类及其子类
   - private 仅定义可以访问
** definition
   #+BEGIN_SRC php

     namespace db;


     class Person
     {
     //    成员属性
	 private $name;
	 private $age;
     //魔术方法
     //__construct 初始化
	 public function __construct($name, $age)
	 {
	     $this->age = $age;
	     $this->name = $name;
	 }

     //静态方法
	 public static function getInstance()
	 {
     //        当前类
	     return new self();
	 }

     //成员方法
	 public function show()
	 {
     //        链式调用
	     echo $this->name . '-' . $this->age;
	     return $this;
	 }
     }
   #+END_SRC
** inherit
   #+BEGIN_SRC php

     namespace db;


     class Person
     {
     //    成员属性
	 private $name;
	 private $age;
     //魔术方法
     //__construct 初始化
	 public function __construct($name, $age)
	 {
	     $this->age = $age;
	     $this->name = $name;
	 }

     //静态方法
	 public static function getInstance()
	 {
     //        当前类
	     return new self();
	 }

     //成员方法
	 public function show()
	 {
     //        链式调用
	     echo $this->name . '-' . $this->age;
	     return $this;
	 }
     }

     //$p = new Person('a', 1);
     //$p->show();

     //继承一般不要超三层
     //多层次推荐用 trait
     //方法重写务必小心，会破会封装特性
     class Student extends Person
     {
	 private $classes;

	 public function __construct($name, $age, $classes)
	 {
     //        父类
	     parent::__construct($name, $age);
	     $this->classes = $classes;
	 }

     //复写、重写方法
	 public function show()
	 {
	     echo '-' . parent::show()->classes;
	 }
     //扩展方法
     //获取器
	 public function getClasses()
	 {
	     return $this->classes;
	 }

     //设置器
	 public function setClasses($classes)
	 {
	     $this->classes = $classes;
	     return $this;
	 }
     }
   #+END_SRC
** 类属性
   #+BEGIN_SRC php

     namespace n;

     class Person
     {
     //静态属性、静态成员、类属性
	 private static $action = 'running';
     //类常量
     //必须初始化
     //不能修改
	 const type = 'animal';
	 private $name;
	 private $age;


	 public static function action()
	 {
	     return self::$action;
	 }

	 public static function type()
	 {
	     return self::type;
	 }

	 public function __construct($name, $age)
	 {
	     $this->name = $name;
	     $this->age = $age;
	 }
     }

     //通过类访问
     echo Person::action() . PHP_EOL;
     echo Person::type() . PHP_EOL;
     //实例访问静态方法
     //不推荐使用，可能以后会取消
     $o = new Person('n', 1);
     echo $o->action() . PHP_EOL;
   #+END_SRC
** 属性重载
   读、写、判断是否存在、删除属性
   #+BEGIN_SRC php
     namespace m;

     class Person
     {
	 private $name;
	 private $age;

	 public function __construct($name, $age)
	 {
	     $this->name = $name;
	     $this->age = $age;
	 }
     //属性重载
     //访问不存在或无权访问的属性触发
	 public function __get($name)
	 {
	     return $this->$name;
	     // TODO: Implement __get() method.
	 }
     //设置属性值
     //修改不存在或无权访问的属性触发
	 public function __set($name, $value)
	 {
	     $this->$name = $value;
	     // TODO: Implement __set() method.
	 }

     //测试是否存在属性
	 public function __isset($name)
	 {
	     return isset($this->$name);
	     // TODO: Implement __isset() method.
	 }

     //删除某属性
	 public function __unset($name)
	 {
	     unset($this->$name);
	     // TODO: Implement __unset() method.
	 }
     }

     $p = new Person('n', 2);
     $p->age = 100;
     echo $p->age . PHP_EOL;
     $p->a = '1';
     echo isset($p->a) . '--isset exist' . PHP_EOL;
     unset($p->a);
     echo isset($p->a) . '--rf exist' . PHP_EOL;
   #+END_SRC
** 回调函数
*** 函数
    #+BEGIN_SRC php
      $fn = function (...$rest) {
	  return $rest;
      };
      //call_user_func_array($fn, [1, 2]);
      print_r(call_user_func($fn, 1, 2));
    #+END_SRC
*** 类静态方法
    #+BEGIN_SRC php
      class Person
      {
	  private const type = 'animal';
	  private static $action = 'running';

	  public function getType()
	  {
	      return self::type;
	  }

	  public static function getAction()
	  {
	      return self::$action;
	  }
      }

      //实例方式调用
      echo call_user_func_array([new Person(), 'getType'], []) . PHP_EOL;
      //静态调用
      //Person::class 返回完整的类对象（包含名字空间）
      echo call_user_func_array([Person::class, 'getAction'], []) . PHP_EOL;
    #+END_SRC
*** 查询构造器
    #+BEGIN_SRC php
      namespace query;
      class Query
      {
	  private $table = '';
	  private $limit = '';
	  private $field = '';
	  private $where = '';

	  public function setKey($name, $value, $is_valid, $default = '')
	  {
	      if ($is_valid) {
		  $value = ' ' . $name . ' ' . $value;
	      } else {
		  $value = $default;
	      }
	      $this->$name = $value;
	      return $this;
	  }

	  public function table($table_name)
	  {
	      return $this->setKey(__FUNCTION__, $table_name, false);
	  }

	  public function field($field_string)
	  {
	      return $this->setKey(__FUNCTION__, $field_string, $field_string, '*');
	  }

	  public function limit($num)
	  {
	      return $this->setKey(__FUNCTION__, $num, gettype($num) === 'integer');
	  }

	  public function where($condition)
	  {
	      return $this->setKey(__FUNCTION__, $condition, $condition);
	  }

	  public function select()
	  {
	      return 'select ' .
		  $this->field .
		  ' from ' .
		  $this->table .
		  $this->where .
		  $this->limit;
	  }
      }


      namespace n;

      class Db
      {

	  public function __call($name, $arguments)
	  {
	      // TODO: Implement __call() method.
	      return self::__callStatic($name, $arguments);
	  }

	  private static function getQueryInstance()
	  {
	      return new \query\Query();
	  }

	  public static function __callStatic($name, $arguments)
	  {
	      // TODO: Implement __callStatic() method.
	      return call_user_func_array([self::getQueryInstance(), $name], $arguments);
	  }
      }

      echo Db::table('tb1')
	      ->field('*')
	      ->where('id > 1')
	      ->limit(10)
	      ->select() . PHP_EOL;

      echo (new Db())
	      ->table('tb2')
	      ->field('id, num')
	      ->where('id > 1 and num > 10')
	      ->limit(1000)
	      ->select() . PHP_EOL;
    #+END_SRC
** 抽象类
   - 抽象类不能实例化
   - 子类必须实现抽象类中的虚方法
   #+BEGIN_SRC php
     abstract class Animal
     {
	 abstract public function say();

     }

     class Bird extends Animal
     {
     //    必须实现抽象方法
	 public function say()
	 {
	     echo 'jj' . PHP_EOL;
	 }
     }
   #+END_SRC
** 接口
   - 接口是类的模板
   - 类是接口的实现
   - 类是对象的模板
   - 对象是类的实现
   - 继承多个接口扩展功能很方便
   - 必须实现接口中的方法
   #+BEGIN_SRC php
     interface Animal
     {
	 public function say();
     }

     interface Action
     {
	 public function move();
     }

     class Duck implements Animal, Action
     {
	 public function say()
	 {
	     echo 'gg' . PHP_EOL;
	     // TODO: Implement say() method.
	 }

	 public function move()
	 {
	     echo 'running' . PHP_EOL;
	 }
     }

   #+END_SRC
*** 接口常量
    #+BEGIN_SRC php
      namespace a;
      if (!interface_exists(__NAMESPACE__ . '\iDbConfig')) {
	  //接口常量
	  interface iDbConfig
	  {
	      const TYPE = 'mysql';
	      const HOST = 'localhost';
	      const DB_NAME = 'db1';
	      const USER_NAME = 'root';
	      const PASSWORD = '';
	      const CHARSET = 'utf8';

	      public static function connection();
	  }
      }

      namespace b;
      use PDO;
      class Connection implements \a\iDbConfig
      {
	  // 直接使用配置的常量进行连接即可
	  public static function connection()
	  {
	      // TODO: Implement connection() method.
	  }
      }
    #+END_SRC
** 类的自动加载
   - 创建./lib/Math.php文件（被使用类的文件）
   - 被使用类的文件名和类名词紧耦合，有规律
   - 被使用类的文件中的命名空间与路径对应
   #+BEGIN_SRC php
     namespace a;
     define('DS', DIRECTORY_SEPARATOR);
     //标准PHP库
     spl_autoload_register(function ($class_name) {
	 $path = __DIR__ . DS . str_replace('\\', DS, $class_name) . '.php';
	 if (file_exists($path)) {
	     include_once $path;
	 }
     });

     echo \lib\Math::add(1, 2) . PHP_EOL;
   #+END_SRC
** 后期静态绑定
   #+BEGIN_SRC php
     //后期静态绑定：延迟静态绑定
     //用在静态继承上下文环境

     class A
     {
	 protected static function s()
	 {
	     echo 'A' . PHP_EOL;
	 }

	 public static function print()
	 {
     //        只调用定义类，不推荐使用
     //        self::s();
     //        根据上下文对象执行对应对象中的方法
	     static::s();
	 }
     }

     class B extends A
     {
	 protected static function s()
	 {
	     echo 'B' . PHP_EOL;
	 }
     }

     B::print();
     A::print();
   #+END_SRC
** 命名空间别名
   #+BEGIN_SRC php
     namespace a;
     class A
     {
     }

     namespace d;
     //'\' 空间分隔符
     //命名空间和路径一致就可以方便使用自动加载了
     //__NAMESPACE__和 namespace 变量是一样的
     //use 默认从全局开始
     //命名空间别名
     //用来防止名称从图
     use a\A;
     //相当于
     //use a\A as A;
     //显示重命名，使用别名
     //use a\A as T;
   #+END_SRC
** trait
   #+BEGIN_SRC php
     namespace e;

     //trait 代码复用
     //优先级高于父类
     //相当于复制一份
     //一般不要在trait中使用$this，尽量弄成纯函数
     class Base
     {
	 protected function connect()
	 {
	     echo __METHOD__ . PHP_EOL;
	 }

	 protected function query()
	 {
	     echo __METHOD__ . PHP_EOL;
	 }
     }

     trait Db
     {
	 protected function connect()
	 {
	     echo __METHOD__ . PHP_EOL;
	 }
     }

     trait Query
     {
	 protected function query()
	 {
	     echo __METHOD__ . PHP_EOL;
	 }
     }

     class Work extends Base
     {
	 use Db;
	 use Query;

	 public function print()
	 {
	     $this->connect();
	     $this->query();
	 }
     }

     (new Work())->print();
   #+END_SRC
* 例子
  - 使用了查询构造器
  - PDO
  - 自动加载
  - 接口
  - 回调函数
** 入口文件
   index.php
   #+BEGIN_SRC php
     <?php

     namespace index;

     define('DS', DIRECTORY_SEPARATOR);
     //标准PHP库
     spl_autoload_register(function ($class_name) {
	 $path = __DIR__ . DS . str_replace('\\', DS, $class_name) . '.php';
	 if (file_exists($path)) {
	     include_once $path;
	 }
     });

     $op = new \lib\OperateCURD();
     //$op->select();
     //$op->insert();
     //$op->insertMul();
     //$op->delete();
     //$op->update();
     $op->select();
   #+END_SRC
** lib目录
   - Db.php
     #+BEGIN_SRC php
       <?php


       namespace lib;

       use \lib\Query;

       class Db
       {
	   public function __call($name, $arguments)
	   {
	       // TODO: Implement __call() method.
	       return self::__callStatic($name, $arguments);
	   }

	   private static function getQueryInstance()
	   {
	       return new Query();
	   }

	   public static function __callStatic($name, $arguments)
	   {
	       // TODO: Implement __callStatic() method.
	       return call_user_func_array([self::getQueryInstance(), $name], $arguments);
	   }

	   public static function connect($config = [])
	   {
	       $joinDsn = function ($arr, $glue_k_v = '=', $glue_item = ';') {
		   $a = [];
		   foreach ($arr as $k => $v) {
		       array_push($a, $k . $glue_k_v . $v);
		   }
		   return join($glue_item, $a);
	       };

	       $conf = [
		   'db' => [
		       'host' => '127.0.0.1',
		       'dbname' => 'db1',
		       'port' => '3306',
		       'charset' => 'utf8'
		   ],
		   'type' => 'mysql',
		   'username' => 'root',
		   'password' => '',
	       ];
	       $conf = empty($config) ? $conf : $config;
	       return new \PDO(
		   $conf['type'] . ':' . $joinDsn($conf['db']),
		   $conf['username'],
		   $conf['password']
	       );
	   }
       }
     #+END_SRC
   - MyArray.php
     #+BEGIN_SRC php
       <?php


       namespace lib;


       class MyArray
       {
	   private $arr;

	   public function __construct($arr)
	   {
	       $this->arr = $arr;
	   }

	   public function pdoPrepare()
	   {
	       $na = [];
	       foreach ($this->arr as $k => $v) {
		   $na[':' . $k] = $v;
	       }
	       return new MyArray($na);
	   }

	   public function joinKey($glue)
	   {
	       return join($glue, array_keys($this->arr));
	   }

	   public function joinValue($glue)
	   {
	       return join($glue, $this->arr);
	   }

	   public function joinKeyValue($kv_glue, $it_glue)
	   {
	       $na = $this->map(function ($v, $k) use ($kv_glue, $it_glue) {
		   return $k . $kv_glue . $v;
	       });
	       return (new MyArray($na))->joinValue($it_glue);
	   }

	   public function forEach($callback)
	   {
	       foreach ($this->arr as $k => $v) {
		   $callback($v, $k);
	       }
	       return $this;
	   }

	   public function map($callback)
	   {
	       $na = [];
	       foreach ($this->arr as $k => $v) {
		   array_push($na, $callback($v, $k));
	       }
	       return new MyArray($na);
	   }

	   public function value()
	   {
	       return $this->arr;
	   }
       }
     #+END_SRC
   - IOperateCURD.php
     #+BEGIN_SRC php
       <?php


       namespace lib;

       interface IOperateCURD
       {
	   public function insert();

	   public function delete();

	   public function update();

	   public function select();

       }
     #+END_SRC
   - OperateCURD.php
     #+BEGIN_SRC php
       <?php


       namespace lib;

       use \lib\IOperateCURD;
       use \lib\Db;
       use \lib\MyArray;

       class OperateCURD implements IOperateCURD
       {
	   private $table;
	   private $pdo;

	   public function __construct()
	   {
	       $this->table = 't1';
	       $this->pdo = Db::connect();
	   }

	   public function insertMul()
	   {
	       $data = [
		   [
		       'name' => '消防1',
		       'department' => '宣传部1',
		       'salary' => 10500,
		       'age' => 66
		   ],
		   [
		       'name' => '有眼2',
		       'department' => '游戏部2',
		       'salary' => 1001,
		       'age' => 22
		   ],
		   [
		       'name' => '风雨3',
		       'department' => '财务部3',
		       'salary' => 110000,
		       'age' => 33
		   ]
	       ];
	       $first = $data[0];
	       $field = (new MyArray($first))->joinKey(',');
	       $value = [];
	       (new MyArray($data))->forEach(function ($item) use (&$value) {
		   (new MyArray($item))->forEach(function ($it) use (&$value) {
		       array_push($value, $it);
		   });
	       });
       //        拼接值部分
	       $v_it = '(' . rtrim(str_repeat('?,', count($first)), ',') . ')';
	       $values = rtrim(str_repeat($v_it . ',', count($data)), ',');
       //        拼接sql
	       $sql = 'insert into '
		   . $this->table .
		   ' ( ' . $field . ' ) '
		   . ' values ' . $values;
	       $pdo = $this->pdo;
	       $stmt = $this->pdo->prepare($sql);
	       if ($stmt->execute($value)) {
		   echo 'lastInsertId = ' . $pdo->lastInsertId() . PHP_EOL;
		   echo 'rowCount = ' . $stmt->rowCount() . PHP_EOL;
	       } else {
		   echo 'insert failure' . PHP_EOL;
	       }
	       return $this;
	   }

	   public function insert()
	   {
	       $data = [
		   'name' => '消防',
		   'department' => '宣传部',
		   'salary' => 1000,
		   'age' => 100
	       ];
	       $o = new MyArray($data);
	       $no = $o->pdoPrepare();
	       $sql = 'insert into '
		   . $this->table
		   . ' ('
		   . $o->joinKey(',')
		   . ') values ('
		   . $no->joinKey(',')
		   . ')';
	       $pdo = $this->pdo;
	       $stmt = $this->pdo->prepare($sql);
	       if ($stmt->execute($o->value())) {
		   echo 'insert mul lastInsertId = ' . $pdo->lastInsertId() . PHP_EOL;
		   echo 'insert mul rowCount = ' . $stmt->rowCount() . PHP_EOL;
	       } else {
		   echo 'insert mul failure' . PHP_EOL;
	       }
	       return $this;
	   }

	   public function delete()
	   {
	       $sql = 'delete from '
		   . $this->table
		   . ' where id < ?';
	       $stmt = $this->pdo->prepare($sql);
	       if ($stmt->execute([5])) {
		   echo 'delete rowCount = ' . $stmt->rowCount() . PHP_EOL;
	       } else {
		   echo 'delete failure' . PHP_EOL;
	       }
	       return $this;
	   }

	   public function update()
	   {
	       $sql = 'update '
		   . $this->table
		   . ' set name = ?, department = ?'
		   . ' WHERE id < ?';
	       $stmt = $this->pdo->prepare($sql);
	       if ($stmt->execute(array('测试', '靠', 7))) {
		   echo 'update rowCount = ' . $stmt->rowCount() . PHP_EOL;
	       } else {
		   echo 'update failure' . PHP_EOL;
	       }
	       return $this;
	   }

	   public function select()
	   {
	       $sql = Db::table($this->table)
		   ->field('*')
		   ->where('id 5 ? ')
		   ->limit(2)
		   ->select();
	       $pdo = $this->pdo;
	       $stmt = $pdo->prepare($sql);
	       if ($stmt->execute(array('2'))) {
		   print_r($stmt->fetchAll(\PDO::FETCH_ASSOC));
	       } else {
		   echo 'select failure' . PHP_EOL;
	       }
	       return $this;
	   }
       }

       //create table t1 (
       //    id int auto_increment primary key,
       //    name varchar(32),
       //    department varchar(16),
       //    salary int,
       //    age tinyint
       //);
     #+END_SRC
   - IQuery.php
     #+BEGIN_SRC php
       <?php


       namespace lib;


       interface IQuery
       {
	   public function table($table_name);

	   public function field($field_string);

	   public function limit($num);

	   public function where($condition);

       //    return sql
	   public function select();
       }
     #+END_SRC
   - Query.php
     #+BEGIN_SRC php
       <?php


       namespace lib;
       use \lib\IQuery;

       class Query implements IQuery
       {
	   private $table = '';
	   private $limit = '';
	   private $field = '';
	   private $where = '';

	   public function table($table_name)
	   {
	       $this->table = $table_name;
	       return $this;
	   }

	   public function field($field_string)
	   {
	       $this->field = $field_string;
	       return $this;
	   }

	   public function limit($num)
	   {
	       $this->limit = ' limit ' . $num;
	       return $this;
	   }

	   public function where($condition)
	   {
	       $this->limit = ' where ' . $condition;
	       return $this;
	   }

	   public function select()
	   {
	       return 'select ' .
		   $this->field .
		   ' from ' .
		   $this->table .
		   $this->where .
		   $this->limit;
	   }
       }
     #+END_SRC
