* 权限
+ public：都能访问
+ protected：定义类和子类可以访问
+ private：仅定义类可以访问
+ 成员属性、成员方法、静态属性、静态方法都有权限控制
+ 成员方法、静态属性默认使用public（权限修饰符可以省略）
+ 非静态、非常量成员属性一定要使用权限修饰符
+ 常量推荐使用大写，不能使用权限修饰符
+ 对象和资源是按引用传递
* 方法中关键字
+ $this：当前对象
+ self：当前类
+ __METHOD__：方法如： T::hide
+ __FUNCTION__ 函数名如： hide
+ parent 父类（也可以是父对象）
* 对象销毁方式
+ 网页执行完毕
+ 函数返回（在函数中创建的临时对象）
+ unset 对象（手动销毁，一次可以销毁多个）
* 使用方式
#+BEGIN_SRC php
  class Student
  {
      public $name = 'abc';
      public $edu;
      private $age;
  }
  $o = new Student();
  //增删改查
  echo $o->name;
  $o->name = 'hello';
  $o->hobby = 123;
  unset($o->edu);
#+END_SRC
* 构造、析构
+ __construct：初始化数据
+ __destruct：释放资源（例如连接之类的）
* 推荐书写板式
#+BEGIN_SRC php
  //类书写方式
  //先写不变的，在写变得，在写方法
  //1 类属性常量
  //2 类静态属性
  //3 变量
  //4 静态方法
  //5 构造析构方法
  //6 一般方法
  class S{
      const NAME = '032';
      private static $sum = 0;
      private $name;
      private $gender;
      private $age;
      //public $showSum; 字段和静态方法名一样，不推荐这样使用
      static function showSum(){
	  return 'sum of S: '.self::$sum;
      }
      public function __construct($name, $gender, $age)
      {
	  $this->name = $name;
	  $this->gender = $gender;
	  $this->age = $age;
	  ++self::$sum;
      }
      function showInfo(){
	  return 'field name'.self::NAME.
	      ', name: '.$this->name.
	      ', gender: '.$this->gender.
	      ', age: '.$this->age;
      }

      public function __destruct()
      {
	  --self::$sum;
	  // TODO: Implement __destruct() method.
      }
  }

  // 对象调用
  $o = new S('haa', '123', 123);
  var_dump($o->showInfo());
  // 静态调用
  var_dump(S::showSum());
#+END_SRC
* 继承
** 基本使用
子类继承父类一切，也可以调用一切有权限执行的方法（包括构造函数）
#+BEGIN_SRC php
  class Person
  {
      const PI = 3.14;
      private $name;
      private $gender;
      private $age;
      static $sum = 0;

      public function __construct($name, $gender, $age)
      {
	  $this->name = $name;
	  $this->gender = $gender;
	  $this->age = $age;
      }

      function show()
      {
	  var_dump($this);
      }
  }

  class Student extends Person
  {
      const PI = 3.1415;
      private $grades;

      public function __construct($grades, $name, $gender, $age)
      {
  //        调用父类构造
	  parent::__construct($name, $gender, $age);
	  $this->grades = $grades;
      }

      function show()
      {
	  parent::show();
	  return parent::$sum;
      }
  }

  //覆盖父类的属性和方法

  var_dump((new Student(1, 2, 2, 3))->show());
#+END_SRC
** 重写
+ 不支持重载
+ 重写的方法函数原型必须相同，访问权限不能变窄
+ 最终类不能继承
+ 最终方法不能重写
+ 最终类和最终方法一般一个类中只有出现一种
#+BEGIN_SRC php
  // 最终类
  Final class College extends Student
  {

  }

  //最终方法
  class Book
  {
  //    推荐这种写法
      final public function show()
      {

      }
       public final function hide()
      {

      }
  }
#+END_SRC
** 抽象类
+ 不能实例化
+ 包含抽象方法的一定是抽象类
+ 抽象类中可以有一般类的所有成员
#+BEGIN_SRC php
  abstract class T
  {
      abstract function inc($a);

      abstract function add($a, $b);
  }
#+END_SRC
* 接口
+ 实现类方法大纲，可以快速了解类的功能
+ 一般只有常量和抽象方法（也可以是静态方法）
+ 必须是public权限
+ 不能加 asstract
+ 子类不能重写常量，可以多继承当常量不能冲突
+ 实现类必须实现所继承的所有接口
+ 接口可以继承接口，类继承类，类实现接口
#+BEGIN_SRC php
  interface Phone{
      function call();
  }

  interface Mp3 {
      function music();
  }

  interface Game{
      function play();
  }

  interface Mp4 extends Mp3{
      function video();
  }

  class Mobile implements Mp4, Phone, Game{
      public function network(){

      }
      public function call()
      {
	  // TODO: Implement call() method.
      }
      public function music()
      {
	  // TODO: Implement music() method.
      }
      public function video()
      {
	  // TODO: Implement movie() method.
      }
      public function play()
      {
	  // TODO: Implement readBook() method.
      }
  }

  $o = new Mobile();
  $o->play();
#+END_SRC

* 自动加载
** 规范
+ 一个类一个文件
+ 一般默认扩展名为 .class.php
+ 类名和文件名一致
** 触发自动调用
+ new 不存在的类
+ 继承不存在的类
+ 调用不存在的类的静态方法
+ 实现不存在的类的接口
** PHP 版本
+ spl_autoload_register > 7
+ __autoload < 7
** 例子
需要先创建装载的目录和文件
#+BEGIN_SRC php
  //注册类的装载规则
  //自动加载
  //一次调用增加一条规则，可以多次使用
  //spl_autoload_register('func_name');
  spl_autoload_register(function ($className){
      $filenames = [
	  "./css/{$className}.css.php",
	  "./js/{$className}.class.php",
      ];
      foreach ($filenames as $pathname){
	  if(file_exists($pathname)){
	      require_once ($pathname);
	  }
      }
  });

  $a = new A();
  $s = new S();
#+END_SRC
* 魔术方法
+ 大部分魔术方法是用来屏蔽系统错误的
+ 创建对象的方式
  - new 对象
  - cloone 对象
+ 销毁对象的方式
  - unset 对象
  - 网页执行完毕
  - 函数中实例化的对象，函数返回（不作为返回值）
#+ATTR_HTML: :border 1 :rules all :frame border
|--------------+--------------------------------------------+--------------------------|
| 方法         | 触发                                       | 例子                     |
|--------------+--------------------------------------------+--------------------------|
| __construct  | 实例化对象                                 | new Obj()                |
|--------------+--------------------------------------------+--------------------------|
| __destruct   | 对象销毁                                   | unset($obj)              |
|--------------+--------------------------------------------+--------------------------|
| __invoke     | 对象当作函数调用                           | $obj()                   |
|--------------+--------------------------------------------+--------------------------|
| __clone      | clone 表达式                               | clone $obj               |
|--------------+--------------------------------------------+--------------------------|
| __toString   | 需要转成转字符串                           | ".".$obj.""              |
|--------------+--------------------------------------------+--------------------------|
| __get        | 获取不存在或不可见的属性                   | $obj->a                  |
|--------------+--------------------------------------------+--------------------------|
| __set        | 给不存在或不可见的属性赋值                 | $obj->a = 123            |
|--------------+--------------------------------------------+--------------------------|
| __unset      | 删除不存在或不可见的属性                   | unset($a->)              |
|--------------+--------------------------------------------+--------------------------|
| __isset      | 判断不存在或不可见的属性是否存在           | isset($obj->a)           |
|--------------+--------------------------------------------+--------------------------|
| __call       | 调用不存在或不可见的方法                   | $obj->a()                |
|--------------+--------------------------------------------+--------------------------|
| __callStatic | 调用不存在或不可见的静态方法               | A::a()                   |
|--------------+--------------------------------------------+--------------------------|
| __sleep      | 序列化时用于指定需要保存的属性（默认全部） | $str = serialize($obj)   |
|--------------+--------------------------------------------+--------------------------|
| __wakeup     | 反序列化时恢复现场（例如连接之类的）       | $obj = unserialize("xx") |
|--------------+--------------------------------------------+--------------------------|

#+BEGIN_SRC php
  class T
  {
      public function __construct()
      {
      }

      public function __destruct()
      {
	  // TODO: Implement __destruct() method.
      }

      public function __clone()
      {
	  // TODO: Implement __clone() method.
      }

      public function __invoke()
      {
	  // TODO: Implement __invoke() method.
      }

      public function __set($name, $value)
      {
	  // TODO: Implement __set() method.
      }

      public function __get($name)
      {
	  // TODO: Implement __get() method.
      }

      public function __isset($name)
      {
	  // TODO: Implement __isset() method.
      }

      public function __unset($name)
      {
	  // TODO: Implement __unset() method.
      }

      public function __call($name, $arguments)
      {
	  // TODO: Implement __call() method.
      }

      public static function __callStatic($name, $arguments)
      {
	  // TODO: Implement __callStatic() method.
      }

      public function __sleep()
      {
	  // TODO: Implement __sleep() method.
      }

      public function __wakeup()
      {
	  // TODO: Implement __wakeup() method.
      }
      //需要返回字符串
      public function __toString()
      {
	  return '';
	  // TODO: Implement __toString() method.
      }
  }
#+END_SRC

* 对象遍历
只能遍历有权限访问的属性
#+BEGIN_SRC php
  //非方法只能遍历有public属性
  foreach ($d as $key=>$value){
      echo "key: {$key}"." value: {$value}";
  }
  echo $a;
  var_dump($a(1, 2));
#+END_SRC
* 序列化
+ serialize 序列化成字符串
+ unserialize 反序列化字符串成变量
+ 例子：'a:3:{i:0;i:1;i:1;i:2;i:2;i:3;}'
  - a: array
  - 3: element number
  - {..} index;value...
  - i:0 int, length is 0
* 后期静态绑定
+ 运行时绑定
+ 优先使用的是实例化对象所对应的类中的属性和方法
+ 受限于可见性，不可见就会报错（和$this表现不太一样）
#+BEGIN_SRC php
  class A
  {
      private function fa()
      {
	  var_dump('A:fa');
      }

      function fn()
      {
	  self::fa();
  //        优先调用实例化对象所在类中的方法
	  $this->fa();
	  static ::fa(); //报错
      }
  }

  class B extends A
  {
      private function fa()
      {
	  var_dump('B:fa');
      }
  }

  $o = new B();
  $o->fn();
  // A:fa
  // A:fa
  // Fatal error: Uncaught Error: Call to private method B::fa() from context 'A' 
#+END_SRC
* 命名空间
+ 默认全局空间
+ 类似虚拟目录，目录重名会合并内容
+ 第一行有效的执行代码之前使用（有的话，第二个及之后的随意，不推荐使用多个）
+ 命名空间仅对类、函数、常量（const方式定义）有效 （define定义的常量在全局空间）
+ 一般写在第一行，接着空一行
#+BEGIN_SRC php
  namespace A;
  class A
  {

  }
  class B{

  }
  namespace B;
  class A
  {

  }

  //当前空间
  new A();
  new namespace\A();
  //全局空间下的B中
  new \B\A();
  //使用命名空间：声明和别名方式
  use \A\B;
  new B();
  use \A\B as B2;
  new B2();

  //子命名空间
  namespace A\Aa\Aaa;
#+END_SRC
* PDO
PHP数据对象，数据库统一接口
#+BEGIN_SRC php
  // 基本使用例子
  $driver = 'mysql';
  $host = '127.0.0.1';
  $port = 3306;
  $db_name = 'db1';
  $charset = 'utf8';
  $username = 'root';
  $password = '';
  $dsn = "{$driver}:$host;port={$port};dbname={$db_name};charset=${charset}";
  try {
      $pdo = new PDO($dsn, $username, $password);
  //print_r($pdo);
  //使用异常形式来提示错误
      $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
      $sql = "insert into user (name ,password) values (:name, :password);";
  //    使用预处理方式执行sql
      $sth = $pdo->prepare($sql);
  //    会过滤一些字符串类似注入之类的
      $sth->bindValue(':name', '小李');
      $sth->bindValue(':password', 'hello');
      $sth->execute();
      var_dump('exec success');
      var_dump($pdo->lastInsertId('id'));
      $sql = "select * from user order by id desc limit 0, 1;";
      $data = $pdo->query($sql);
      var_dump($data->fetchAll(PDO::FETCH_ASSOC));
  } catch (Exception $e) {
      print_r($e->getMessage());
  //    var_dump($pdo->errorInfo());
  //    var_dump($pdo->errorCode());
  }
#+END_SRC
* 模板渲染
以smarty为例（git 上下源码来使用，简单使用例子）
#+BEGIN_SRC php
  require_once '../smarty/libs/Smarty.class.php';

  $s = new Smarty();
  $s->left_delimiter = '{{';
  $s->right_delimiter = '}}';
  $s->setTemplateDir('./libs');
  $s->setConfigDir('./js');

  $s->assign('hello', 'lihao123');
  $s->assign('arr', ['Jeck', 'fork', 'Blam']);
  $_GET['password'] = 'xxxx111';
  $_GET['lan'] = 'en';
  const TT = '123';
  $s->display('test.html');
#+END_SRC
#+BEGIN_SRC html
  <ul>
      <li><h3>{{$arr.0}}</h3></li>
      <li><h3>{{$arr.1}}</h3></li>
      <li>密码：{{$smarty.get.password}}</li>
      <li>method:{{$smarty.server.REQUEST_METHOD}}</li>
      <li>const:{{$smarty.const.TT}}</li>
      <li>php timestamp:{{date('Y-m-d H:i:s')}}</li>
      <li>smarty timestamp:{{$smarty.now|date_format: '%Y-%m-%d %H:%M:%S'}}</li>
      {{config_load file='config.ini' section=$smarty.get.lan}}
      <li>config value: {{$smarty.config.title}}</li>
      <li>config value: {{#typename#}}</li>
      <li>language value: {{$smarty.config.a}}</li>
      {{foreach $arr as $k=>$v}}
      <li><h5>arr[{{$k}}]={{$v}}</h5></li>
      {{/foreach}}
      {{foreach from=$arr key="key" item="value"}}
      <li><h5>arr[{{$k}}]={{$v}}</h5></li>
      {{/foreach}}
  </ul>
#+END_SRC
#+BEGIN_SRC conf
  title = 中文字符
  typename = php

  [tw]
  a = chinese
  [en]
  a = english
#+END_SRC
